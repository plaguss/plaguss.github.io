[{"content":"In this 3 part series I will tell the journey of creating a program to detect the different components/entities of a command line program\u0026rsquo;s help message. This post will start by looking at the final product, helpner, a python program that can be installed from PyPI, the second will tell about the spaCy NLP workflow and finally we will take a look at the data that feeds spaCy.\nThe post assumes some python knowledge, like how to install a library from PyPI, and some familiarity with spaCy.\nThe following figure shows the architecture of helpner, each piece is represented by a different github repository. Highlighted in wellow at the bottom its the piece corresponding to helpner.\nWhat led me to start this project? I wanted an NLP project to put into practice the spaCy facilities. If possible, the model should be ready to use by an end user without developing a website for it for simplicity. Independently, I found docopt by chance exploring python CLI libraries. As it turns out, this library, and its maintained fork docopt-ng can generate a CLI program by parsing a \u0026ldquo;properly written\u0026rdquo; help message (visit the previous link to see an example). This same idea seemed like a good opportunity.\nCan we solve this using a Named Entity Recognition model? \u0026hellip;I don\u0026rsquo;t care if its not the best approach\nLets try to write a CLI program that can take a help message from another CLI program, and find the different elements or entities (commands, arguments and options) which conform it. It turns out that in around 200 lines of code, we can have a promising first version. Of course, this is not that simple, but with spaCy it feels like it üëå.\nEnter helpner Lets see how helpner works. The installation consists of two steps. First, install using pip as usual (preferably inside a venv, it should be possible to install it using pipx, but I haven\u0026rsquo;t tried it yet):\n$ pip install helpner This should have downloaded the library, but as of this moment, its incomplete, we still have to download the model itself. For this, a handy command is supplied (visit the README.md for more information):\n$ helpner download This two step process should be familiar for those who have already used spaCy. By using this approach it allows to split the development of the model from the use we make of it. We could update the model in any way (we could for example retrain the model with different data, or modify the optimizer used), and we would only need to update the model. It applies the same for the library, we could add more functionality without changing the inner model.\nWe are already in position to use helpner üí•, lets see one of the examples from the docs, how to highlight the entities of a help message (this was the first use that came to mind):\nflit install --help | helpner highlight For those who don\u0026rsquo;t know flit, its a command line program that simplifies packaging python modules. The example shows the help message of one of its subcommands, flit install. From the legend we see that the possible elements or entities are CMD (commands or subcommands, which in this case depend on flit directly), ARG (positional arguments, which in this case don\u0026rsquo;t exist) and OPT (optional arguments, which correspond to all the elements preceded by a single or double dash, are correctly predicted). But it calls the attention some random words highlighted as if they were CMD entities, which are clearly misplaced. It is far from perfect, but I consider it a success anyway, the results seem promising enough!\nWhat happens underneath? what we did was send the help message to the spaCy model, and get the predictions:\n‚ùØ flit install --help | helpner parse --no-json { \u0026#39;install\u0026#39;: (\u0026#39;CMD\u0026#39;, 12, 19), \u0026#39;[-h]\u0026#39;: (\u0026#39;OPT\u0026#39;, 20, 24), \u0026#39;[-s]\u0026#39;: (\u0026#39;OPT\u0026#39;, 25, 29), \u0026#39;[--pth-file]\u0026#39;: (\u0026#39;OPT\u0026#39;, 30, 42), \u0026#39;[--user]\u0026#39;: (\u0026#39;OPT\u0026#39;, 43, 51), \u0026#39;[--env]\u0026#39;: (\u0026#39;OPT\u0026#39;, 52, 59), \u0026#39;[--python PYTHON]\u0026#39;: (\u0026#39;OPT\u0026#39;, 60, 77), \u0026#39;[--deps {all,production,develop,none}]\u0026#39;: (\u0026#39;OPT\u0026#39;, 98, 136), \u0026#39;[--only-deps]\u0026#39;: (\u0026#39;OPT\u0026#39;, 137, 150), \u0026#39;[--extras EXTRAS]\u0026#39;: (\u0026#39;OPT\u0026#39;, 171, 188), \u0026#39;-h, --help\u0026#39;: (\u0026#39;OPT\u0026#39;, 201, 211), \u0026#39;exit\u0026#39;: (\u0026#39;CMD\u0026#39;, 250, 254), \u0026#39;-s, --symlink\u0026#39;: (\u0026#39;OPT\u0026#39;, 257, 270), \u0026#39;package\u0026#39;: (\u0026#39;CMD\u0026#39;, 298, 305), \u0026#39;--pth-file\u0026#39;: (\u0026#39;OPT\u0026#39;, 373, 383), \u0026#39;module\u0026#39;: (\u0026#39;CMD\u0026#39;, 417, 423), \u0026#39;/\u0026#39;: (\u0026#39;CMD\u0026#39;, 423, 424), \u0026#39;--user\u0026#39;: (\u0026#39;OPT\u0026#39;, 497, 503), \u0026#39;local\u0026#39;: (\u0026#39;CMD\u0026#39;, 529, 534), \u0026#39;--env\u0026#39;: (\u0026#39;OPT\u0026#39;, 612, 617), \u0026#39;--python PYTHON\u0026#39;: (\u0026#39;OPT\u0026#39;, 749, 764), \u0026#39;--deps {all,production,develop,none}\u0026#39;: (\u0026#39;OPT\u0026#39;, 862, 898), \u0026#39;--only-deps\u0026#39;: (\u0026#39;OPT\u0026#39;, 1074, 1085), \u0026#39;--extras EXTRAS\u0026#39;: (\u0026#39;OPT\u0026#39;, 1192, 1207), \u0026#39;the\u0026#39;: (\u0026#39;CMD\u0026#39;, 1313, 1316), \u0026#39;ones\u0026#39;: (\u0026#39;CMD\u0026#39;, 1317, 1321), \u0026#39;implied\u0026#39;: (\u0026#39;CMD\u0026#39;, 1322, 1329), \u0026#39;by\u0026#39;: (\u0026#39;CMD\u0026#39;, 1330, 1332), \u0026#39;be\u0026#39;: (\u0026#39;CMD\u0026#39;, 1382, 1384), \u0026#39;useful\u0026#39;: (\u0026#39;CMD\u0026#39;, 1385, 1391) } This output has all the necessary information to inform rich. The keys in the dict correspond to the elements found/predicted, and the values contain the entity, start and end position of the substrings. With this information, we can make use of rich to add some color to the console.\nOf course, there are multiple errors (and this is an example that seems relatively right), the model cannot be better than the data it was fed with. In a posterior post we will see how the data powering this model is obtained.\n","permalink":"https://plaguss.github.io/blog/a-ner-model-for-command-line-help-messages-part1/","summary":"In this 3 part series I will tell the journey of creating a program to detect the different components/entities of a command line program\u0026rsquo;s help message. This post will start by looking at the final product, helpner, a python program that can be installed from PyPI, the second will tell about the spaCy NLP workflow and finally we will take a look at the data that feeds spaCy.\nThe post assumes some python knowledge, like how to install a library from PyPI, and some familiarity with spaCy.","title":"A NER Model for Command Line Help Messages (Part 1: The console program)"},{"content":"","permalink":"https://plaguss.github.io/archive/","summary":"archive","title":"Archive"}]