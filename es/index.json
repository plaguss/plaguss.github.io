[{"content":"En esta serie de 3 partes voy a contar el viaje de crear un programa para detectar los diferentes componentes/entidades del mensaje de ayuda de un programa por l√≠nea de comandos. Esta entrada comenzar√° echando un vistazo al producto final helpner, un programa escrito en python que se puede instalar desde PyPI, la segunda parte tratar√° el flujo de trabajo de un pipeline en spaCy y finalmente echaremos un vistazo a los datos de los que se alimentar√° spaCy para el modelo final.\nEsta entrada asume algo de conocimiento de python, como instalar librer√≠as de PyPI, y cierta familiaridad con spaCy.\nLa siguiente imagen muestra la arquitectura de helpner, cada pieza est√° representada por un repostorio de github diferente. Resaltado en amarillo en la parte inferior tenemos la parte correspondiente a helpner.\nQue me llev√≥ a empezar este proyecto? SEGUIR AQU√ç\nQuer√≠a un proyecto de NLP para practicar algunas de las muchas facilidades que ofrece spaCy. De ser posible, el modelo deber√≠a ser f√°cil de usar por un usuario sin tener que crear una p√°gina web por simplicidad. Por otro lado, encontr√© docopt de casualidad mientras exploraba librer√≠as de python para crear CLIs. Resulta que esta librer√≠a y el fork de la misma que tiene mantenimiento (docopt-ng), pueden generar una CLI procesando un mensaje de ayuda escrito \u0026ldquo;apropiadamente\u0026rdquo; (vista el link previo para ver los ejemplos). Esta misma idea parec√≠a una buena oportunidad.\nSe puede resolver este problema utilizando un modelo NER? \u0026hellip;No me importa si no es el mejor enfoque\nVamos a escribir un programa para la consola que pueda tomar un mensaje de ayuda de otro programa, y encontrar los diferentes elementos/entidades (comandos, argumentos y opciones) que lo conforman. Resulta que en alrededor de 200 lineas de c√≥digo, podemos tener una primera versi√≥n prometedora üòÑ. Est√° claro que no es tan sencillo internamente, pero spaCy hace que lo parezca.\nEntra helpner Veamos como funciona helpner. La instalaci√≥n consiste en dos pasos. Primero, instalamos con pip como es habitual, preferiblemente dentro de un venv. (Deber√≠a ser posible instalarlo utilizando pipx, pero no lo he probado todav√≠a).\n$ pip install helpner Este comando deber√≠a descargar la librer√≠a, pero en este momento esta incompleta, todav√≠a debemos descargar el modelo que utiliza internamente. Para esto, se ofrece un comando conveniente (se puede visitar el README.md para m√°s informaci√≥n):\n$ helpner download Este proceso en dos pasos deber√≠a ser familiar a aquellos que ya conozcan spaCy. Utilizando este enfoque podemos separar el desarollo del modelo de el uso que hacemos del mismo. Podr√≠amos actualizar el modelo de cualquier forma (por ejemplo reentrenarlo con datos distintos, o modificar el optimizador que utiliza), y solo necesitariamos actualizar el modelo (reejecutando el comando de descarga). Ocurre lo mismo con la librer√≠a, podemos a√±adir m√°s funcionalidad sin necesidad de actualizar el modelo.\nYa estamos listos para utilizar helpner üí•, veamos uno de los ejemplos de la documentaci√≥n, como resaltar las entidades del de un mensaje de ayuda (este fue el primer caso de uso que se me vino a la mente).\nflit install --help | helpner highlight Para quien no conozca flit, es un programa por consola que simplifica empaquetar modulos de python. Este ejemplo muestra el mensaje de ayuda de uno de sus subcomandos, flit install. En la leyenda podemos ver que los posibles elementos o entidades son CMD (commandos o subcomandes, que en este caso depende de flit directamente), ARG (argumentos posicionales, que no aparecen en este caso) y OPT (argumentos opcionales, que corresponden a todos los elementos que est√°n precedidos de uno o dos guiones, y el modelo ha predicho correctamente). Pero llaman la atenci√≥n unas cuantas palabras al azar que salen resaltadas como si fueran CMD, que est√°n claramente mal predichas. El modelo est√° lejos de ser perfecto, pero lo considero un √©xito igualmente, los resultados parecen lo bastante prometedores!\n¬øQue ocurre por debajo? lo que hemos hecho ha sido mandar el mensaje de ayuda al modelo de spaCy, y hemos obtenido las predicciones:\n‚ùØ flit install --help | helpner parse --no-json { \u0026#39;install\u0026#39;: (\u0026#39;CMD\u0026#39;, 12, 19), \u0026#39;[-h]\u0026#39;: (\u0026#39;OPT\u0026#39;, 20, 24), \u0026#39;[-s]\u0026#39;: (\u0026#39;OPT\u0026#39;, 25, 29), \u0026#39;[--pth-file]\u0026#39;: (\u0026#39;OPT\u0026#39;, 30, 42), \u0026#39;[--user]\u0026#39;: (\u0026#39;OPT\u0026#39;, 43, 51), \u0026#39;[--env]\u0026#39;: (\u0026#39;OPT\u0026#39;, 52, 59), \u0026#39;[--python PYTHON]\u0026#39;: (\u0026#39;OPT\u0026#39;, 60, 77), \u0026#39;[--deps {all,production,develop,none}]\u0026#39;: (\u0026#39;OPT\u0026#39;, 98, 136), \u0026#39;[--only-deps]\u0026#39;: (\u0026#39;OPT\u0026#39;, 137, 150), \u0026#39;[--extras EXTRAS]\u0026#39;: (\u0026#39;OPT\u0026#39;, 171, 188), \u0026#39;-h, --help\u0026#39;: (\u0026#39;OPT\u0026#39;, 201, 211), \u0026#39;exit\u0026#39;: (\u0026#39;CMD\u0026#39;, 250, 254), \u0026#39;-s, --symlink\u0026#39;: (\u0026#39;OPT\u0026#39;, 257, 270), \u0026#39;package\u0026#39;: (\u0026#39;CMD\u0026#39;, 298, 305), \u0026#39;--pth-file\u0026#39;: (\u0026#39;OPT\u0026#39;, 373, 383), \u0026#39;module\u0026#39;: (\u0026#39;CMD\u0026#39;, 417, 423), \u0026#39;/\u0026#39;: (\u0026#39;CMD\u0026#39;, 423, 424), \u0026#39;--user\u0026#39;: (\u0026#39;OPT\u0026#39;, 497, 503), \u0026#39;local\u0026#39;: (\u0026#39;CMD\u0026#39;, 529, 534), \u0026#39;--env\u0026#39;: (\u0026#39;OPT\u0026#39;, 612, 617), \u0026#39;--python PYTHON\u0026#39;: (\u0026#39;OPT\u0026#39;, 749, 764), \u0026#39;--deps {all,production,develop,none}\u0026#39;: (\u0026#39;OPT\u0026#39;, 862, 898), \u0026#39;--only-deps\u0026#39;: (\u0026#39;OPT\u0026#39;, 1074, 1085), \u0026#39;--extras EXTRAS\u0026#39;: (\u0026#39;OPT\u0026#39;, 1192, 1207), \u0026#39;the\u0026#39;: (\u0026#39;CMD\u0026#39;, 1313, 1316), \u0026#39;ones\u0026#39;: (\u0026#39;CMD\u0026#39;, 1317, 1321), \u0026#39;implied\u0026#39;: (\u0026#39;CMD\u0026#39;, 1322, 1329), \u0026#39;by\u0026#39;: (\u0026#39;CMD\u0026#39;, 1330, 1332), \u0026#39;be\u0026#39;: (\u0026#39;CMD\u0026#39;, 1382, 1384), \u0026#39;useful\u0026#39;: (\u0026#39;CMD\u0026#39;, 1385, 1391) } Este output tiene toda la informaci√≥n necesaria para informar a rich. Las claves del diccionario corresponden a los elementos encontrados/predichos, y los valores contienen la entidad, comienzo y posici√≥n final de los \u0026ldquo;substrings\u0026rdquo;. Con esta informaci√≥n, podemos hacer uso de rich para a√±adir algo de color a la consola.\nPor supuesto, hay muchos errores (y este es un ejemplo que parece relativamente correcto), el modelo no puede predecir mejor que los datos de los que se ha alimentado. En otro post m√°s adelante veremos como se obtienen los datos que alimentan este modelo.\n","permalink":"https://plaguss.github.io/es/blog/a-ner-model-for-command-line-help-messages-part1/","summary":"En esta serie de 3 partes voy a contar el viaje de crear un programa para detectar los diferentes componentes/entidades del mensaje de ayuda de un programa por l√≠nea de comandos. Esta entrada comenzar√° echando un vistazo al producto final helpner, un programa escrito en python que se puede instalar desde PyPI, la segunda parte tratar√° el flujo de trabajo de un pipeline en spaCy y finalmente echaremos un vistazo a los datos de los que se alimentar√° spaCy para el modelo final.","title":"Un modelo NER para los mensajes de ayuda de las consolas (Parte 1: el programa en l√≠nea de comandos)"},{"content":"","permalink":"https://plaguss.github.io/archive/","summary":"archive","title":"Archive"}]